pipeline {
    agent any
 
    environment {
        SSH_CREDENTIALS_ID = 'azure_vm_key'
        APP_REPO_URL = 'https://github.com/AzizSoftware/SSAFT_DEPLOYMENT_PIPELINE.git'

        AZURE_SUB_ID_CRED = 'azure-subscription-id'
        AZURE_CLIENT_ID_CRED = 'azure-client-id'
        AZURE_CLIENT_SECRET_CRED = 'azure-client-secret'
        AZURE_TENANT_ID_CRED = 'azure-tenant-id'

        AZURE_STORAGE_ACCOUNT_NAME = 'ssaftyouruniqueappstorage'
        AZURE_STORAGE_CONTAINER_NAME = 'app-releases'
    }

    stages {
        stage('Checkout Main Repo') {
            steps {
                script {
                    checkout([
                        $class: 'GitSCM',
                        branches: [[name: 'main']],
                        userRemoteConfigs: [[url: env.APP_REPO_URL, credentialsId: 'github-pat-azizsoftware']],
                        doNotPoll: true
                    ])
                    sh 'pwd'
                    sh 'ls -lR'
                }
            }
        }

        stage('Parallel Deployments and Artifact Publishing') {
            parallel {
                stage('Infrastructure and Application Deployment') {
                    stages {
                        stage('Terraform Init and Apply') {
                            steps {
                                dir('terraform') {
                                    withCredentials([
                                        string(credentialsId: env.AZURE_SUB_ID_CRED, variable: 'ARM_SUBSCRIPTION_ID'),
                                        string(credentialsId: env.AZURE_CLIENT_ID_CRED, variable: 'ARM_CLIENT_ID'),
                                        string(credentialsId: env.AZURE_CLIENT_SECRET_CRED, variable: 'ARM_CLIENT_SECRET'),
                                        string(credentialsId: env.AZURE_TENANT_ID_CRED, variable: 'ARM_TENANT_ID')
                                    ]) {
                                        sh '''
                                            terraform init -reconfigure
                                            terraform plan \
                                                -var="subscription_id=$ARM_SUBSCRIPTION_ID" \
                                                -var="client_id=$ARM_CLIENT_ID" \
                                                -var="client_secret=$ARM_CLIENT_SECRET" \
                                                -var="tenant_id=$ARM_TENANT_ID"

                                            terraform apply -auto-approve \
                                                -var="subscription_id=$ARM_SUBSCRIPTION_ID" \
                                                -var="client_id=$ARM_CLIENT_ID" \
                                                -var="client_secret=$ARM_CLIENT_SECRET" \
                                                -var="tenant_id=$ARM_TENANT_ID"
                                        '''
                                    }
                                }
                            }
                        }

                        stage('Wait for VM & SSH Readiness') {
                            steps {
                                script {
                                    def vmIp = sh(script: "cd terraform && terraform output -raw public_ip_address", returnStdout: true).trim()
                                    sh """
                                        mkdir -p ~/.ssh
                                        chmod 700 ~/.ssh
                                        touch ~/.ssh/known_hosts
                                        chmod 600 ~/.ssh/known_hosts
                                    """
                                    sh '''
                                        count=0
                                        while ! nc -z -v -w 10 ''' + vmIp + ''' 22; do
                                            echo "Waiting for SSH on ''' + vmIp + '''..."
                                            sleep 5
                                            count=$((count+1))
                                            if [ $count -ge 18 ]; then
                                                echo "Timeout waiting for SSH"
                                                exit 1
                                            fi
                                        done
                                        echo "SSH is ready on ''' + vmIp + '''"
                                    '''
                                }
                            }
                        }

                        stage('Ansible Deploy') {
                            steps {
                                dir('ansible') {
                                    withCredentials([sshUserPrivateKey(credentialsId: env.SSH_CREDENTIALS_ID, keyFileVariable: 'ANSIBLE_PRIVATE_KEY_FILE_PATH')]) {
                                        script {
                                            def vmIp = sh(script: "cd ../terraform && terraform output -raw public_ip_address", returnStdout: true).trim()
                                            def vmAdminUsername = sh(script: "cd ../terraform && terraform output -raw vm_admin_username", returnStdout: true).trim()

                                            sh """
                                                ssh-keygen -R ${vmIp} || true
                                                ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ${ANSIBLE_PRIVATE_KEY_FILE_PATH} ${vmAdminUsername}@${vmIp} exit
                                            """

                                            sh """
                                                echo "[webservers]" > inventory.ini
                                                echo "azure_vm ansible_host=${vmIp} ansible_user=${vmAdminUsername}" >> inventory.ini
                                                echo "[all:vars]" >> inventory.ini
                                                echo "ansible_python_interpreter=/usr/bin/python3" >> inventory.ini
                                            """

                                            withEnv(["ANSIBLE_KEY_VAR=${ANSIBLE_PRIVATE_KEY_FILE_PATH}"]) {
                                                sh """
                                                    ansible-playbook deploy_app.yml \
                                                        -i inventory.ini \
                                                        --private-key=\${ANSIBLE_KEY_VAR} \
                                                        -e app_repo_url=${env.APP_REPO_URL} \
                                                        -e ansible_host_key_checking=False \
                                                        -e "ansible_ssh_extra_args='-o UserKnownHostsFile=/dev/null'"
                                                """
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                stage('Package and Deploy Application Artifact') {
                    agent any
                    steps {
                        script {
                            def targetBranch = "Upgrade-branch"
                            dir("package_and_deploy_temp_${env.BUILD_NUMBER}") {
                                checkout([
                                    $class: 'GitSCM',
                                    branches: [[name: targetBranch]],
                                    userRemoteConfigs: [[url: env.APP_REPO_URL, credentialsId: 'github-pat-azizsoftware']],
                                    doNotPoll: true
                                ])

                                def archiveFileName = "ssa-ft-app-v${env.BUILD_NUMBER}.tar.gz"
                                sh "tar -czf ${archiveFileName} SSATF"

                                withCredentials([
                                    string(credentialsId: env.AZURE_SUB_ID_CRED, variable: 'ARM_SUBSCRIPTION_ID'),
                                    string(credentialsId: env.AZURE_CLIENT_ID_CRED, variable: 'ARM_CLIENT_ID'),
                                    string(credentialsId: env.AZURE_CLIENT_SECRET_CRED, variable: 'ARM_CLIENT_SECRET'),
                                    string(credentialsId: env.AZURE_TENANT_ID_CRED, variable: 'ARM_TENANT_ID')
                                ]) {
                                    withEnv([
                                        "AZURE_STORAGE_ACCOUNT_NAME=${env.AZURE_STORAGE_ACCOUNT_NAME}",
                                        "AZURE_STORAGE_CONTAINER_NAME=${env.AZURE_STORAGE_CONTAINER_NAME}"
                                    ]) {
                                        sh """
                                            az login --service-principal -u "\$ARM_CLIENT_ID" -p "\$ARM_CLIENT_SECRET" --tenant "\$ARM_TENANT_ID"
                                            az account set --subscription "\$ARM_SUBSCRIPTION_ID"

                                            az storage blob upload \
                                                --account-name "\${AZURE_STORAGE_ACCOUNT_NAME}" \
                                                --container-name "\${AZURE_STORAGE_CONTAINER_NAME}" \
                                                --file "${archiveFileName}" \
                                                --name "${archiveFileName}" \
                                                --overwrite true

                                            az logout
                                        """
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        stage('Smoke Test') {
            steps {
                dir('terraform') {
                    script {
                        def ip = sh(script: "terraform output -raw public_ip_address", returnStdout: true).trim()
                        sh "curl --fail http://${ip}:4000"
                    }
                }
            }
        }
    }

    post {
        success {
            echo "✅ CD pipeline succeeded."
        }
        failure {
            echo "❌ CD pipeline failed."
        }
    }
}
