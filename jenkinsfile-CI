pipeline {
    agent any

    environment {
        NODEJS_VERSION = 'node-18'
        TEST_PIPELINE = 'SSAFT_TEST_PIPELINE'
        SSH_CREDENTIALS_ID = 'azure_vm_key'
        APP_REPO_URL = 'https://github.com/AzizSoftware/SSAFT_DEPLOYMENT_PIPELINE.git'
    }

    tools {
        nodejs "${env.NODEJS_VERSION}"
    }

    stages {
        stage('Checkout Repo') {
            steps {
                script {
                    checkout([
                        $class: 'GitSCM',
                        branches: [[name: 'main']],
                        userRemoteConfigs: [[
                            url: env.APP_REPO_URL,
                            credentialsId: 'github-pat-azizsoftware'
                        ]],
                        doNotPoll: true
                    ])
                    echo "Listing contents after checkout:"
                    sh 'pwd'
                    sh 'ls -lR'
                }
            }
        }

        stage('Bump Versions and Push') {
            steps {
                script {
                    def updatedModules = [
                        'SSATF/Services/TransactionGenerationAPI',
                        'SSATF/Services/DataAnalyserService',
                        'SSATF/Client_UI'
                    ]

                    def filesToCommit = []
                    def newVersions = [:]

                    // Bump version for each module
                    updatedModules.each { modulePath ->
                        def pkgPath = "${modulePath}/package.json"
                        def json = readJSON file: pkgPath
                        def versionParts = json.version.tokenize('.')
                        versionParts[2] = (versionParts[2] as int) + 1
                        json.version = versionParts.join('.')
                        writeJSON file: pkgPath, json: json, pretty: 4

                        newVersions[modulePath] = json.version
                        filesToCommit << pkgPath
                        echo "üîÅ Version bumped to ${json.version} in ${modulePath}"
                    }

                    // Create dynamic branch name based on one of the bumped versions (Client_UI here)
                    def newVersionClientUI = newVersions['SSATF/Client_UI']
                    def branchName = "Upgraded-branch-${newVersionClientUI}"
                    env.UPGRADE_BRANCH_NAME = branchName
                    echo "üìå New branch name: ${branchName}"

                    withCredentials([usernamePassword(
                        credentialsId: '4a0363b8-3a92-4661-9c34-18f42434b7e7',
                        usernameVariable: 'GIT_USER',
                        passwordVariable: 'GIT_TOKEN'
                    )]) {
                        // Use a shell script with explicit args for secrets, avoiding interpolation warnings
                        sh script: '''
                            set -e
                            git config user.email "jenkins@azizsoftware.com"
                            git config user.name "Jenkins CI"

                            git checkout main
                            git pull

                            # Stash local changes before switching branch
                            if git diff --quiet && git diff --cached --quiet; then
                                echo "No local changes"
                            else
                                echo "Stashing local changes"
                                git stash
                            fi

                            if git rev-parse --verify ${BRANCH_NAME} >/dev/null 2>&1; then
                                echo "‚úÖ Branch ${BRANCH_NAME} exists, checking out"
                                git checkout ${BRANCH_NAME}
                            else
                                echo "üîß Creating new branch ${BRANCH_NAME}"
                                git checkout -b ${BRANCH_NAME}
                            fi

                            # Apply stashed changes back if any
                            if git stash list | grep -q 'stash@{0}'; then
                                echo "Applying stashed changes"
                                git stash pop || true
                            fi

                            # Add modified package.json files
                            ''' + filesToCommit.collect { "git add '${it}'" }.join('\n') + '''

                            # Commit if there are changes
                            if ! git diff --cached --quiet; then
                                git commit -m "üîº Bump versions: ''' + newVersions.collect { k,v -> "${k.split('/').last()}: ${v}" }.join(', ') + '''"
                            else
                                echo "No changes to commit"
                            fi

                            # Push branch using credentials passed as env variables to avoid interpolation warnings
                            git push https://${GIT_USER}:${GIT_TOKEN}@github.com/AzizSoftware/SSAFT_DEPLOYMENT_PIPELINE.git ${BRANCH_NAME}
                        ''', 
                        env: [
                            "BRANCH_NAME=${branchName}",
                            "GIT_USER=${env.GIT_USER}",
                            "GIT_TOKEN=${env.GIT_TOKEN}"
                        ]
                    }
                }
            }
        }

        stage('Install Dependencies') {
            steps {
                echo "Installing dependencies in subprojects..."

                dir('SSATF/Services/DataAnalyserService') {
                    echo "Installing in DataAnalyserService"
                    sh 'npm install'
                }

                dir('SSATF/Services/TransactionGenerationAPI') {
                    echo "Installing in TransactionGenerationAPI"
                    sh 'npm install'
                }

                dir('SSATF/Client_UI') {
                    echo "Installing in Client_UI"
                    sh 'npm install'
                }
            }
        }
    }

    post {
        success {
            echo "‚úÖ CI pipeline succeeded. Triggering Test Pipeline..."
            build job: "${env.TEST_PIPELINE}", wait: true, parameters: [
                string(name: 'UPGRADE_BRANCH_NAME', value: env.UPGRADE_BRANCH_NAME)
            ]
        }
        failure {
            echo "‚ùå CI pipeline failed. Aborting further steps."
        }
    }
}
